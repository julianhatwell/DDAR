---
title: "Discrete Data Analysis"
subtitle: "A Friendly Guide to Visualising Categorical Data"
author: "Julian Hatwell"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  beamer_presentation:
    colortheme: "seahorse"
    fonttheme: "structurebold"
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(warning = FALSE
              , message = FALSE
              , echo = FALSE
              )

library(lattice)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(vcd)
library(vcdExtra)
source("KTheme.R")
```

# Introduction

## About Me

* Over 15 years in enterprise systems, management information systems and BI in the for-profit education sector, UK and Singapore
* MSc (Distinction) Business Intelligence, Birmingham City University. Master's Dissertation: *An Association Rules Based Method for Imputing Missing Likert Scale Data*
* Research to PhD (in progress): *Designing Explanation Systems for Decision Forests*, Data Analytics and Artifical Intelligence research group, Birmingham City University  

## Academic Analytics

```{r}
include_graphics("acadsys.png")
```

## Academic Analytics

**Monitor, Evaluate and Optimise**

* Typical BI analysis of sales and marketing (student recruitment), financial, HR, operations, etc
* **student life-cycle**: recruitment to alumni services
* class room utilisation and exam planning
* lecturer management (part-time and adjunct)

## Credits

::: {.columns}
::: {.column}
* **Michael Friendly** is a pioneer in this field and has contributed to the development of modules and libraries for SAS and R. Ideas and examples based on material contained in this book.

* Shorter, valuable tutorial on these topics:
  * **R> library("vcd")**
  * **R> vignette("vcd")**

* https://www.youtube.com/watch?v=qfNsoc7Tf60 for an in depth lecture, by Michael Friendly.

:::
::: {.column}

```{r book_info, echo=FALSE, fig.cap="Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data", out.width = '100%'}
include_graphics("ddar_book_info.png", dpi=30)
```

:::
:::

## Analysis of Categorical Data

**Rigorous statistical analysis of categorical data is not only supported by visual tools, it is best performed visually.**

This is the main theme of Michael Friendly's work.

## Exploring Data with Area Based Plots

HairEyeColor (R datasets)

592 stats students, self-categorised, University of Delaware, 1974.

```{r describe_haireye, echo=FALSE}
hr_desc <- data.frame(No=1:3
                      , Name=c("Hair", "Eye", "Sex")
                      , Levels=c("Black, Brown, Red, Blond", "Brown, Hazel, Green, Blue", "Male, Female"))
kable(hr_desc)
```

## Limitations of Working with Tables Directly

```{r HEC, echo=TRUE}
# re-order the eye colours dark to light.
HEC <- HairEyeColor[, c("Brown", "Hazel"
                        , "Green", "Blue"), ]

# collapse over 3rd margin (Sex)
haireye <- margin.table(HEC, 1:2)

# vcd::structable package makes pivot tables
structable(haireye)
```

## Naive Approach: Barplots

Does hair colour depend on eye colour or does eye colour depend on hair colour?

Can we succinctly describe the relationship?

```{r not_intuitive, fig.fullwidth=TRUE, fig.height = 4}
my_gbars <- function(g) {
  g + stat_identity(geom = "bar"
                , position = position_dodge()) +
  myGgFillScale4 +
  theme_bw() +
  myGgTheme
}

g1 <- ggplot(data = as.data.frame(haireye)
             , aes(x = Hair
                   , fill = Eye
                   , y = Freq))
g1 <- my_gbars(g1)
  

g2 <- ggplot(data = as.data.frame(haireye)
             , aes(x = Eye
                   , fill = Hair
                   , y = Freq))

g2 <- my_gbars(g2)

grid.arrange(g1, g2, nrow=1)
```

## Introducing the Strucplot Framework

* Purpose built for handling tables - no dependent/independent variables.
* Respects the table structure given.
* Several Variants: mosaic, sieve, tile, assoc, spine, doubledecker
* Focus of this talk: mosaic (most versatile, higher dimensional)
* Properties of mosaic plots:
    1. Tile area $\propto$ frequency.
    1. Independence expectation: straight grid lines in the mosaic when marginal frequencies of one feature are constant over all levels of another feature.
    1. Deviations from expectation show up as deviations in the grid lines. Shading provides a visual cue.

**Con:** Another plotting system to learn.

## Example Code

```{r example_mosaic, echo=TRUE, eval=FALSE}
mosaic(myTable
   , shade = TRUE # highlight deviations?
   , split_vertical = TRUE # control split directions
   , main="Title"
   , labeling = labeling_values # show cell values?
   , spacing = spacing_equal(
     sp = unit(0.5, "lines"))
   , value_type = "observed"
   , gp_text = gpar(fontface = 1) # graphical params
   , rot_labels = c(0, 90, 0, -30)) # tidy label rotation
```

## Hair Marginal Totals

```{r h_marg}
mosaic(margin.table(haireye, 1)
       , main="Hair Marginal Totals"
       , shade = TRUE
       , labeling = labeling_values
       , spacing = spacing_equal(sp = unit(0.5, "lines"))
       , value_type = "observed"
       , gp_text = gpar(fontface = 1))
```

## Eye Marginal Totals

```{r e_marg}
mosaic(margin.table(haireye, 2)
       , split_vertical = TRUE
       , main="Eye Marginal Totals"
       , shade = TRUE
       , labeling = labeling_values
       , spacing = spacing_equal(sp = unit(0.5, "lines"))
       , value_type = "observed"
       , gp_text = gpar(fontface = 1))

expected <- independence_table(haireye)
```

## Expected Frequencies Under Independence Assumption

```{r exp_freqs}
mosaic(expected
      , main="Expected frequencies"
      , shade = TRUE
      , labeling = labeling_values
      , spacing = spacing_equal(sp = unit(0.5, "lines"))
      , value_type = "expected"
      , gp_text = gpar(fontface = 1))
```

## Observed Frequencies

```{r hr_actuals}
mosaic(haireye
      , gp = shading_hcl # shade = TRUE
      , main="Actual frequencies"
      , labeling = labeling_values
      , value_type = "observed"
      , gp_text = gpar(fontface = 1))
```

## Friendly Colour Scheme

```{r hr_actuals_friend}
# visualising actual counts for independent features
mosaic(haireye
      , gp = shading_Friendly # shade = TRUE
      , main="Actual frequencies"
      , labeling = labeling_values
      , value_type = "observed"
      , gp_text = gpar(fontface = 1))
```

## Code for the Previous Mosaic

```{r hr_actuals_friend, eval=FALSE, echo=TRUE}
```

## Previous + Sex Feature: Now in 3-D

```{r hec}
# showing all three dimensions
mosaic(HEC
      , gp = shading_Friendly # shade = TRUE
      , main="Actual frequencies"
      , labeling = labeling_values
      , value_type = "observed"
      , gp_text = gpar(fontface = 1), rot_labels = c(right = -45)) 
```

## What You See Depends on the Pivot

The base R comes with lots of functions for maniptulating tables. Packages "vcd" and "vcdExtra" provide many more.

```{r aperm_piv, echo=TRUE}
# pivoting example
HEC_pivot <- aperm(HEC, 3:1)
```

## What You See Depends on the Pivot

```{r hec2}
# with a different pivot
mosaic(HEC_pivot
      , gp = shading_Friendly # shade = TRUE
      , main="Actual frequencies HEC_pivot"
      , labeling = labeling_values
      , value_type = "observed"
      , gp_text = gpar(fontface = 1), rot_labels = c(right = -45)) 
```

## Loglinear Models

Two discrete variables *A* with *I* possible values and  *B* with *J* possible values. A sample can be described by an *I* $\times$ *J* contingency table

```{r conting_table_example}
dimnames(haireye) <- list(A = c("A_1", "A_2", "A_3", "A_4")
                          , B = c("B_1", "B_2", "B_3", "B_4"))
haireye
```

Under independence, each cell count in the table is assumed to be a Poisson distibuted random variable:

$$n_{ij} \sim \mathit{Pois}(\frac{n_{i+} \cdot n_{+j}}{n_{++}})$$

## Loglinear Models

Rearranging, we get a model that is linear in all the logs:

$$\frac{n_{i+} \cdot n_{+j}}{n_{++}} = \log(n_{i+}) + \log(n_{+j}) - \log(n_{++})$$

This is usually represented as:

$$\mu + \lambda^A_i + \lambda^B_j$$

where the $\lambda$ terms are the "main" effects and $\mu$ is in "intercept" term that is a property of the total count.

Under independence, the main effects can be calculated directly from the marginal totals.

## Loglinear Models

Deviation from independence implies an interaction term:

$$\mu + \lambda^A_i + \lambda^B_j + \lambda^{AB}_{ij}$$

Constraining $\sum^I_{i = 1} \sum^J_{j = 1} \lambda^{AB}_{ij} = 0$ means that there are $(I-1)(J-1)$ degrees of freedom.

This scales to more variables as follows:

$$\mu + \lambda^A_i + \lambda^B_j + \lambda^C_k + \lambda^{AB}_{ij} + \lambda^{BC}_{jk} + \lambda^{AC}_{ik} + \lambda^{ABC}_{ijk}$$

This is referred to as the saturated model - will be a near perfect fit.

## Loglinear Models

When modelling, we seek the most parsimious, best fit. Find a model that is:

* as "good" as the saturated model
* does not use all the degrees of freedom

This can be done using:

* generalised linear models
* comparing various interactions (joint, conditional)
* dummy variables can capture very specific interactions

Anova tests and AIC/BIC are used to determine the best model.

## Loglinear Models

```{r freq_glm, echo=TRUE}
# convert to frequency form data frame
HEC_df <- as.data.frame(HEC)
head(HEC_df, 3)

# explanatory model, hair eye interaction
hec.glm <- glm(Freq~Hair*Eye+Sex
               , data=HEC_df
               , family = poisson)
```

## HEC Observed

```{r hec2, eval=TRUE}
```


## HEC GLM

```{r hec_glm, echo=TRUE, eval=FALSE}
mosaic(hec.glm # invokes the glm plotting method
       , main="Hair*Eye"
       , gp = shading_Friendly
       , formula = ~ Sex + Eye + Hair # mosaic layout
       , residuals_type = "rstandard")
```

## HEC GLM

```{r hec_glm, eval=TRUE}
```

## HEC GLM 2

```{r glm2, echo=TRUE, eval=FALSE}
# convert to frequency form data frame
HEC_df$Blbl <- factor(ifelse(HEC_df$Hair == "Blond" &
                               HEC_df$Eye == "Blue" &
                               HEC_df$Sex == "Female"
                             , TRUE
                             , FALSE))

# explanatory model, hair eye interaction
hec.glm2 <- glm(Freq~Hair*Eye+Sex+Blbl
               , data=HEC_df
               , family = poisson)

mosaic(hec.glm2 # invokes the glm plotting method
       , main="Hair*Eye | Blond-Blue*Sex"
       , gp = shading_Friendly
       , formula = ~ Sex + Eye + Hair # mosaic layout
       , residuals_type = "rstandard")
```

## HEC GLM 2

```{r glm2, eval=TRUE}
```

## HEC GLM tests

```{r glmtests, echo=TRUE}
anova(hec.glm, hec.glm2)
LRstats(hec.glm2) # compare to saturated

```
# End